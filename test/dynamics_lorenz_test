import pypose.module.dynamics as ppmd
import numpy as np
import torch as torch
import torch.nn as nn
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Create class for Lorenz dynamics
class LorenzAttractor(ppmd._System):
    def __init__(self,dt,time=False):
        super(LorenzAttractor,self).__init__(time)
        self._sigma = nn.Parameter(torch.rand(1))
        self._rho = nn.Parameter(torch.rand(1))
        self._beta = nn.Parameter(torch.rand(1))
        self._tau = dt

    def state_transition(self,state,input):
        x, y, z = torch.squeeze(torch.clone(state))
        xdot = self._sigma*(y-x)
        ydot = x*(self._rho-z)-y
        zdot = x*y-self._beta*z
        dstate = torch.stack((xdot,ydot,zdot),axis=1)
        return state + torch.mul(dstate,self._tau)

    def observation(self,state,input):
        return state

    def loss(self,true,pred):
        return torch.sqrt(torch.mean((true-pred)**2))

if __name__=="__main__":

    torch.autograd.set_detect_anomaly(True)

    # Create Lorenz attractor dynamics
    IC = np.array([-8,8,27])
    # Constant declarations
    sigma = 10
    rho = 28
    beta = 8/3
    # Derivative function
    def f(t,x):
        xdot = sigma*(x[1]-x[0])
        ydot = x[0]*(rho-x[2])-x[1]
        zdot = x[0]*x[1]-beta*x[2]
        return xdot,ydot,zdot
    # Create time span for trajectory prediction
    tspan = [0.001,10]                                 # Simluation time span
    num_tsteps = 1000                                  # Number of time steps
    t_eval = np.linspace(tspan[0],tspan[1],num_tsteps) # Vector of all times
    t_step = t_eval[1] - t_eval[0]                     # Find time step size
    # Solve for trajectory
    sol = solve_ivp(f,tspan,IC,method='DOP853',t_eval=t_eval,vectorized=True,rtol=1e-12,atol=1e-12)
    sol = torch.tensor(sol.y).float()
    
    lorenzSolver = LorenzAttractor(t_step)

    pred = torch.zeros(np.shape(sol))
    state = torch.tensor(IC).float()
    pred[:,0] = state;

    # stateTransitionOptim = torch.optim.Adam(lorenzSolver.parameters(),lr=0.01)

    loss = torch.inf
    while loss > 0.1:
        for i in range(1,num_tsteps):
            next_state,_ = lorenzSolver.forward(state,0)
            pred[:,i] = next_state 
            state = next_state
        loss = lorenzSolver.loss(sol,pred)
        # loss.backward(retain_graph=True)
        # stateTransitionOptim.step()

    print(lorenzSolver._sigma)
    print(lorenzSolver._beta)
    print(lorenzSolver._rho)