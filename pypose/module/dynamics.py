import torch as torch
import torch.nn as nn
import pypose as pp
from torch.autograd.functional import jacobian


class _System(nn.Module):
    def __init__(self, time=False):
        super().__init__()
        self.jacargs = {'vectorize':True, 'strategy':'reverse-mode'}
        if time:
            self.register_buffer('t',torch.zeros(1))
            self.register_forward_hook(self.forward_hook)

    def forward_hook(self, module, inputs, outputs):
        self.input, self.state = inputs
        self.t.add_(1)

    def forward(self, state, input):
        state = self.state_transition(state, input)
        return self.observation(state, input)

    def state_trasition(self):
        pass

    def observation(self):
        pass

    def reset(self,t=0):
        self.t.fill_(0)

    @property
    def A(self):
        if hasattr(self, '_A'):
            return self._A
        else:
            func = lambda x: self.state_trasition(x, self.input)
            return jacobian(func, self.state, **self.jacargs)

    @property
    def B(self):
        if hasattr(self, '_B'):
            return self._B
        else:
            func = lambda x: self.state_trasition(self.state, x)
            return jacobian(func, self.input, **self.jacargs)

    @property
    def C(self):
        if hasattr(self, '_C'):
            return self._C
        else:
            func = lambda x: self.observation(x, self.input)
            return jacobian(func, self.state, **self.jacargs)
 
    @property
    def D(self):
        if hasattr(self, '_D'):
            return self._D
        else:
            func = lambda x: self.observation(self.state, x)
            return jacobian(func, self.input, **self.jacargs)


class LTI(_System):
    r'''
    A sub-class of '_System' to represent Linear Time-Invariant system.
    
    Args:
        A, B, C, D (:obj:`Tensor`): The coefficient matrix in the state-space equation of LTI system
        c1, c2 (:obj:`Tensor`): Bias generated by system
        
    Note:
        According to the actual physical meaning, the dimensions of A, B, C, D must be the same,
        whether in the batch case or not.
        
        The system is time invariant.
    '''
    def __init__(self, A, B, C, D, c1=None, c2=None):
        super(LTI, self).__init__(time=False)
        assert A.ndim == B.ndim == C.ndim == D.ndim, "Invalid System Matrices dimensions"
        self._A, self._B, self._C, self._D = A, B, C, D
        self._c1, self._c2 = c1, c2

    @property
    def c1(self):
        return self._c1
    
    @property
    def c2(self):
        return self._c2
    
    def forward(self, x, u):
        r'''
        Args:
            x (:obj:`Tensor`): The state of LTI system,
            u (:obj:`Tensor`): The input of LTI system.

        Return:
            Tensor: The solved batched tensor, which means state-transition and observation of the system.

            
        Every linear time-invariant lumped system can be described by a set of equations of the form
        which is called the state-space equation.
        
        .. math::
            \begin{align*}
                z_{i} = A_{i} \times x_{i} + B_{i} \times u_{i} + c_1 \\
                y_{i} = C_{i} \times x_{i} + D_{i} \times u_{i} + c_2 \\
            \end{align*}
            
        where :math:`x` is actually :math:`\dot{x}`, the differential form of :math:`x`.
        
        Let the input be matrix :math:`A`, :math:`B`, :math:`C`, :math:`D`, :math:`x`, :math:`u`, :math:`c_1`, :math:`c_2`. 
        :math:`x_i` represents each individual matrix in the batch. 
        
        Note:
            -:math:`x`, :math:`u` could be single input or multiple inputs

            -:math:`A`, :math:`B`, :math:`C`, :math:`D` can only be two-dimensional matrices or the batch
             In the batch case, their dimensions must be the same as those of :math:`x`, :math:`u`. 
             :math:`A`, :math:`B`, :math:`C`, :math:`D` and :math:`x`, :math:`u` are multiplied separately for each channel.
             
            -For a System with p inputs, q outputs, and n state variables, :math:`A`, :math:`B`, :math:`C`, :math:`D` are n*n n*p q*n and q*p constant matrices.
             
            -Note that variables are entered as row vectors.

        Example:
            >>> A = torch.randn((5,4,4))
                B = torch.randn((5,4,2))
                C = torch.randn((5,3,4))
                D = torch.randn((5,3,2))
                c1 = torch.randn((5,1,4))
                c2 = torch.randn((5,1,3))
                x = torch.randn((5,1,4))
                u = torch.randn((5,1,2))
            >>> A
            tensor([[[-2.1307, -0.0265, -0.9746,  2.1318],
                     [ 0.8923, -1.2088,  0.5181,  0.2247],
                     [ 1.2783,  1.6348, -0.4024, -0.8853],
                     [-0.5250, -0.8087, -0.2149,  0.9131]],
                    [[ 1.1460,  0.2928,  0.9220,  0.8167],
                     [-0.4724,  0.7346,  2.6626, -0.0576],
                     [-0.2195, -0.0968,  1.6650, -0.8698],
                     [-0.3657,  0.2261,  0.5464, -0.5526]]]) 
                B
            tensor([[[ 0.7123, -0.7718],
                     [-1.2862,  0.4408],
                     [ 1.2668, -0.6137],
                     [-1.1583, -0.8909]],
                    [[ 1.8226, -0.0915],
                     [ 1.0294, -0.1818],
                     [-0.3554, -0.3590],
                     [ 0.7268,  0.6523]]])
                C
            tensor([[[ 0.9161,  0.3633, -0.5458, -1.6204],
                     [ 0.0950, -1.8612, -1.1077, -0.6735],
                     [ 1.7566,  1.5171,  1.5716, -0.1131]],
                    [[-0.2392, -0.1495,  1.1992, -0.9145],
                     [-0.8053, -0.7873, -0.4930, -0.0717],
                     [-2.1565,  2.0012,  1.1418,  1.2976]]]) 
                D
            tensor([[[ 0.0101, -0.4622],
                     [-1.5069,  0.6238],
                     [ 0.5393, -0.5627]],
                    [[ 1.4681,  0.9441],
                     [-0.0878, -0.9124],
                     [ 0.2210,  0.1803]]])  
                c1
            tensor([[[ 0.4976, -0.0424, -1.4534, -1.6975]],
                    [[ 0.0611, -1.2238,  0.0298, -0.4679]]])  
                c2
            tensor([[[ 0.1361,  0.3252,  0.4346]],
                    [[-0.6390,  0.2950, -1.1937]]]) 
                x
            tensor([[[-0.1116, -1.4881, -0.5404, -0.4778]],
                    [[-0.3715,  1.3025, -0.3283, -0.4953]]])  
                u
            tensor([[[-0.6876,  1.0977]],
                    [[ 0.1704, -1.3875]]])
            >>> lti = LTI(A, B, C, D, c1, c2)
            tensor([[[-1.0540,  2.6377, -4.9331, -0.9371]],
                    [[-0.2530, -0.5093,  0.3071, -0.7244]]]), 
            tensor([[[ 0.0481,  5.7256, -3.8027]],
                    [[-1.7453,  1.0173,  0.9837]]]))
    
        Note:
            In this general example, all variables are in the batch. User definable as appropriate.
            
        '''

        if self.A.ndim >= 3:
            assert self.A.ndim == x.ndim == u.ndim,  "Invalid System Matrices dimensions"
        else:
            assert self.A.ndim == 2,  "Invalid System Matrices dimensions"

        z = x.matmul(self._A.mT) + u.matmul(self._B.mT) + self._c1
        y = x.matmul(self._C.mT) + u.matmul(self._D.mT) + self._c2

        return z, y
