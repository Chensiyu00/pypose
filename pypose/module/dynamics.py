import torch as torch
import torch.nn as nn
import pypose as pp
from torch.autograd.functional import jacobian


class _System(nn.Module):
    def __init__(self, time=False):
        super().__init__()
        self.jacargs = {'vectorize':True, 'strategy':'reverse-mode'}
        if time:
            self.register_buffer('t',torch.zeros(1))
            self.register_forward_hook(self.forward_hook)

    def forward_hook(self, module, inputs, outputs):
        self.input, self.state = inputs
        self.t.add_(1)

    def forward(self, state, input):
        state = self.state_transition(state, input)
        return self.observation(state, input)

    def state_trasition(self):
        pass

    def observation(self):
        pass

    def reset(self,t=0):
        self.t.fill_(0)

    @property
    def A(self):
        if hasattr(self, '_A'):
            return self._A
        else:
            func = lambda x: self.state_trasition(x, self.input)
            return jacobian(func, self.state, **self.jacargs)

    @property
    def B(self):
        if hasattr(self, '_B'):
            return self._B
        else:
            func = lambda x: self.state_trasition(self.state, x)
            return jacobian(func, self.input, **self.jacargs)

    @property
    def C(self):
        if hasattr(self, '_C'):
            return self._C
        else:
            func = lambda x: self.observation(x, self.input)
            return jacobian(func, self.state, **self.jacargs)
 
    @property
    def D(self):
        if hasattr(self, '_D'):
            return self._D
        else:
            func = lambda x: self.observation(self.state, x)
            return jacobian(func, self.input, **self.jacargs)


class LTI(_System):
    r'''
    A sub-class of '_System' to represent Linear Time-Invariant system.
    
    Args:
        A, B, C, D (:obj:`Tensor`): The coefficient matrix in the state-space equation of LTI system
        c1, c2 (:obj:`Tensor`): Bias generated by system
        
    Note:
        According to the actual physical meaning, the dimensions of A, B, C, D must be the same,
        whether in the batch case or not.
        
        The system is time invariant.
    '''
    def __init__(self, A, B, C, D, c1=None, c2=None):
        super(LTI, self).__init__(time=False)
        assert A.ndim == B.ndim == C.ndim == D.ndim, "Invalid System Matrices dimensions"
        self._A, self._B, self._C, self._D = A, B, C, D
        self._c1, self._c2 = c1, c2

    @property
    def c1(self):
        return self._c1
    
    @property
    def c2(self):
        return self._c2
    
    def forward(self, x, u):
        r'''
        Args:
            x (:obj:`Tensor`): The state of LTI system,
            u (:obj:`Tensor`): The input of LTI system.

        Return:
            Tensor: The solved batched tensor, which means state-transition and observation of the system.

            
        Every linear time-invariant lumped system can be described by a set of equations of the form
        which is called the state-space equation.
        
        .. math::
            \begin{align*}
                z_{i} = A_{i} \times x_{i} + B_{i} \times u_{i} + c_1 \\
                y_{i} = C_{i} \times x_{i} + D_{i} \times u_{i} + c_2 \\
            \end{align*}
            
        where :math:`x` is actually :math:`\dot{x}`, the differential form of :math:`x`.
        
        Let the input be matrix :math:`A`, :math:`B`, :math:`C`, :math:`D`, :math:`x`, :math:`u`, :math:`c_1`, :math:`c_2`. 
        :math:`x_i` represents each individual matrix in the batch. 
        
        Note:
            -:math:`x`, :math:`u` could be single input or multiple inputs

            -:math:`A`, :math:`B`, :math:`C`, :math:`D` can only be two-dimensional matrices or the batch
             In the batch case, their dimensions must be the same as those of :math:`x`, :math:`u`. 
             :math:`A`, :math:`B`, :math:`C`, :math:`D` and :math:`x`, :math:`u` are multiplied separately for each channel.
             
            -For a System with p inputs, q outputs, and n state variables, :math:`A`, :math:`B`, :math:`C`, :math:`D` are n*n n*p q*n and q*p constant matrices.
             
            -Note that variables are entered as row vectors.

        Example:
            >>> A = torch.randn((2,3,3))
                B = torch.randn((2,3,2))
                C = torch.randn((2,3,3))
                D = torch.randn((2,3,2))
                c1 = torch.randn((2,1,3))
                c2 = torch.randn((2,1,3))
                x = torch.randn((2,1,3))
                u = torch.randn((2,1,2))
            >>> A
            tensor([[[-2.1218, -0.0558,  1.6897],
                     [ 0.3156, -0.7407, -0.0628],
                     [ 0.7567,  0.6081,  0.0089]],
                    [[-0.4036,  1.0982,  0.4694],
                     [ 0.3743,  0.7851, -1.4842],
                     [-1.0845, -0.8888, -0.0843]]])
                B
            tensor([[[-0.8426, -1.3793],
                     [ 0.2805, -0.1517],
                     [-0.3015,  0.0862]],
                    [[-0.4926,  0.7835],
                     [-0.1341,  0.1560],
                     [-0.4062,  0.3711]]]) 
                C
            tensor([[[-0.6730,  0.1076,  0.7406],
                     [-0.9979,  0.9915, -1.5760],
                     [-0.7343,  0.5490,  0.5513]],
                    [[-0.3741, -0.7521,  0.4004],
                     [-1.4800,  0.0868,  0.1175],
                     [ 0.2590,  1.4560, -0.3273]]]) 
                D
            tensor([[[ 1.2974, -1.0183],
                     [-0.0850, -1.9760],
                     [ 0.7531, -0.6172]],
                    [[-0.3685,  0.0948],
                     [-0.9020, -2.0040],
                     [ 0.5833,  1.0258]]])   
                c1
            tensor([[[ 0.9888,  0.1157, -1.2387]],
                    [[ 0.5319, -1.3769, -0.0701]]])   
                c2
            tensor([[[-0.6067, -1.8852, -0.8722]],
                    [[-0.3974,  2.1444,  0.5077]]]) 
                x
            tensor([[[ 0.9576,  0.6824, -2.3676]],
                    [[-0.5359,  1.4186,  0.9334]]])  
                u
            tensor([[[ 1.0024,  1.9124]],
                    [[-0.9396,  1.1412]]])
            >>> lti = LTI(A, B, C, D, c1, c2)
            tensor([[[-8.5639,  0.0523, -0.2576]],
                    [[ 4.1013, -1.5452, -0.0233]]]), 
            tensor([[[-3.5780, -2.2970, -2.9314]],
                    [[-0.4358,  1.7306,  2.7514]]]))
    
        Note:
            In this general example, all variables are in the batch. User definable as appropriate.
            
        '''

        if self.A.ndim >= 3:
            assert self.A.ndim == x.ndim == u.ndim,  "Invalid System Matrices dimensions"
        else:
            assert self.A.ndim == 2,  "Invalid System Matrices dimensions"

        z = x.matmul(self._A.mT) + u.matmul(self._B.mT) + self._c1
        y = x.matmul(self._C.mT) + u.matmul(self._D.mT) + self._c2

        return z, y
